import { createCmdKey as O, commandsTimerCtx as I, CommandsReady as R, commandsCtx as d, editorStateTimerCtx as A, SchemaReady as l, inputRulesCtx as C, schemaCtx as f, schemaTimerCtx as E, marksCtx as w, nodesCtx as k, prosePluginsCtx as p, editorViewTimerCtx as D, nodeViewCtx as v, markViewCtx as $, InitReady as N, remarkPluginsCtx as b, editorViewCtx as y, serializerCtx as H, parserCtx as M, editorStateOptionsCtx as L } from "@milkdown/core";
import { createTimer as F, createSlice as U } from "@milkdown/ctx";
import { customAlphabet as q } from "nanoid";
import { missingMarkInSchema as P, missingNodeInSchema as j } from "@milkdown/exception";
import { keymap as z } from "@milkdown/prose/keymap";
import { NodeType as T, DOMSerializer as B, Slice as K } from "@milkdown/prose/model";
import { EditorState as G } from "@milkdown/prose/state";
const J = q("abcedfghicklmn", 10), g = (n, a, r) => {
  const t = F(r || J());
  let e = !1;
  const s = (o) => (o.record(t), o.update(a, (c) => c.concat(t)), async () => {
    const u = await n(o, s, () => {
      o.done(t), e = !0;
    });
    return e || o.done(t), () => {
      o.update(a, (i) => i.filter((m) => m !== t)), o.clearTimer(t), u == null || u();
    };
  });
  return s.timer = t, s;
}, re = (n, a) => {
  const r = O(n), t = (e) => async () => {
    t.key = r, await e.wait(R);
    const s = a(e);
    return e.get(d).create(r, s), t.run = (o) => e.get(d).call(n, o), () => {
      e.get(d).remove(r);
    };
  };
  return t;
}, se = (n, a, r) => {
  const t = O(n);
  return g(
    async (e, s) => {
      await e.wait(R);
      const o = await a(e);
      return e.get(d).create(t, o), s.run = (c) => e.get(d).call(n, c), s.key = t, () => {
        e.get(d).remove(t);
      };
    },
    I,
    r
  );
}, ae = (n) => {
  const a = (r) => async () => {
    await r.wait(l);
    const t = n(r);
    return r.update(C, (e) => [...e, t]), a.inputRule = t, () => {
      r.update(C, (e) => e.filter((s) => s !== t));
    };
  };
  return a;
}, oe = (n, a) => g(
  async (r, t) => {
    await r.wait(l);
    const e = await n(r);
    return r.update(C, (s) => [...s, e]), t.inputRule = e, () => {
      r.update(C, (s) => s.filter((o) => o !== e));
    };
  },
  A,
  a
), Q = (n, a) => {
  const r = (t) => async () => {
    const e = a(t);
    return t.update(w, (s) => [...s.filter((o) => o[0] !== n), [n, e]]), r.id = n, r.schema = e, () => {
      t.update(w, (s) => s.filter(([o]) => o !== n));
    };
  };
  return r.type = (t) => {
    const e = t.get(f).marks[n];
    if (!e)
      throw P(n);
    return e;
  }, r;
}, ce = (n, a, r) => {
  const t = g(
    async (e, s, o) => {
      const c = await a(e);
      return e.update(w, (u) => [...u.filter((i) => i[0] !== n), [n, c]]), s.id = n, s.schema = c, o(), () => {
        e.update(w, (u) => u.filter(([i]) => i !== n));
      };
    },
    E,
    r
  );
  return t.type = (e) => {
    const s = e.get(f).marks[n];
    if (!s)
      throw P(n);
    return s;
  }, t;
}, W = (n, a) => {
  const r = (t) => async () => {
    const e = a(t);
    return t.update(k, (s) => [...s.filter((o) => o[0] !== n), [n, e]]), r.id = n, r.schema = e, () => {
      t.update(k, (s) => s.filter(([o]) => o !== n));
    };
  };
  return r.type = (t) => {
    const e = t.get(f).nodes[n];
    if (!e)
      throw j(n);
    return e;
  }, r;
}, ie = (n, a, r) => {
  const t = g(
    async (e, s, o) => {
      const c = await a(e);
      return e.update(k, (u) => [...u.filter((i) => i[0] !== n), [n, c]]), s.id = n, s.schema = c, o(), () => {
        e.update(k, (u) => u.filter(([i]) => i !== n));
      };
    },
    E,
    r
  );
  return t.type = (e) => {
    const s = e.get(f).nodes[n];
    if (!s)
      throw j(n);
    return s;
  }, t;
}, ue = (n) => {
  let a;
  const r = (t) => async () => (await t.wait(l), a = n(t), t.update(p, (e) => [...e, a]), () => {
    t.update(p, (e) => e.filter((s) => s !== a));
  });
  return r.plugin = () => a, r.key = () => a.spec.key, r;
}, me = (n, a) => {
  let r;
  const t = g(
    async (e) => (await e.wait(l), r = await n(e), e.update(p, (s) => [...s, r]), () => {
      e.update(p, (s) => s.filter((o) => o !== r));
    }),
    A,
    a
  );
  return t.plugin = () => r, t.key = () => r.spec.key, t;
}, X = (n) => {
  const a = (r) => async () => {
    await r.wait(l);
    const t = n(r), e = z(t);
    return r.update(p, (s) => [...s, e]), a.keymap = t, () => {
      r.update(p, (s) => s.filter((o) => o !== e));
    };
  };
  return a;
}, pe = (n, a) => g(
  async (r, t) => {
    await r.wait(l);
    const e = await n(r), s = z(e);
    return r.update(p, (o) => [...o, s]), t.keymap = e, () => {
      r.update(p, (o) => o.filter((c) => c !== s));
    };
  },
  A,
  a
), le = (n, a) => {
  const r = (t) => async () => {
    await t.wait(l);
    const e = a(t);
    return n.type(t) instanceof T ? t.update(v, (s) => [...s, [n.id, e]]) : t.update($, (s) => [...s, [n.id, e]]), r.view = e, r.type = n, () => {
      n.type(t) instanceof T ? t.update(v, (s) => s.filter((o) => o[0] !== n.id)) : t.update($, (s) => s.filter((o) => o[0] !== n.id));
    };
  };
  return r;
}, de = (n, a, r) => g(
  async (t, e) => {
    await t.wait(l);
    const s = await a(t);
    return n.type(t) instanceof T ? t.update(v, (o) => [...o, [n.id, s]]) : t.update($, (o) => [...o, [n.id, s]]), e.view = s, e.type = n, () => {
      n.type(t) instanceof T ? t.update(v, (o) => o.filter((c) => c[0] !== n.id)) : t.update($, (o) => o.filter((c) => c[0] !== n.id));
    };
  },
  D,
  r
), h = (n, a) => {
  const r = U(n, a), t = (e) => (e.inject(r), () => () => {
    e.remove(r);
  });
  return t.key = r, t;
}, ye = (n, a) => {
  const r = h(a, n), t = W(n, (s) => s.get(r.key)(s)), e = [r, t];
  return e.id = t.id, e.node = t, e.type = (s) => t.type(s), e.schema = t.schema, e.ctx = r, e.key = r.key, e.extendSchema = (s) => (o) => () => {
    const c = o.get(r.key), i = s(c)(o);
    o.update(k, (m) => [...m.filter((S) => S[0] !== n), [n, i]]), e.schema = i;
  }, e;
}, ge = (n, a) => {
  const r = h(a, n), t = Q(n, (s) => s.get(r.key)(s)), e = [r, t];
  return e.id = t.id, e.mark = t, e.type = t.type, e.schema = t.schema, e.ctx = r, e.key = r.key, e.extendSchema = (s) => (o) => () => {
    const c = o.get(r.key), i = s(c)(o);
    o.update(w, (m) => [...m.filter((S) => S[0] !== n), [n, i]]), e.schema = i;
  }, e;
}, fe = (n, a) => {
  const r = Object.fromEntries(Object.entries(a).map(([o, { shortcuts: c }]) => [o, c])), t = h(r, `${n}Keymap`), e = X((o) => {
    const c = o.get(t.key), u = Object.entries(a).flatMap(([i, { command: m }]) => [c[i]].flat().map((V) => [V, m(o)]));
    return Object.fromEntries(u);
  }), s = [t, e];
  return s.ctx = t, s.shortcuts = e, s.key = t.key, s.keymap = e.keymap, s;
}, he = (n, a = () => ({})) => h(a, `${n}Attr`), we = (n, a = () => ({})) => h(a, `${n}Attr`), ke = (n, a, r) => {
  const t = h(r ?? {}, n), e = (o) => async () => {
    await o.wait(N);
    const u = {
      plugin: a(o),
      options: o.get(t.key)
    };
    return o.update(b, (i) => [...i, u]), () => {
      o.update(b, (i) => i.filter((m) => m !== u));
    };
  }, s = [t, e];
  return s.id = n, s.plugin = e, s.options = t, s;
};
function Se(n, a) {
  return (r) => r.get(d).call(n, a);
}
const Ce = () => (n) => {
  const a = n.get(y), { tr: r } = a.state, t = Object.assign(Object.create(r), r).setTime(Date.now());
  return a.dispatch(t);
}, ve = () => (n) => {
  const a = document.createElement("div"), r = n.get(f), t = n.get(y), e = B.fromSchema(r).serializeFragment(t.state.doc.content);
  return a.appendChild(e), a.innerHTML;
}, $e = () => (n) => {
  const a = n.get(y);
  return n.get(H)(a.state.doc);
}, Te = (n) => (a) => {
  const r = a.get(y), e = a.get(M)(n);
  if (!e)
    return;
  const s = r.state.selection.content();
  return r.dispatch(
    r.state.tr.replaceSelection(new K(e.content, s.openStart, s.openEnd)).scrollIntoView()
  );
}, Ae = () => (n) => {
  const a = n.get(y), r = [];
  return a.state.doc.descendants((e) => {
    e.type.name === "heading" && e.attrs.level && r.push({ text: e.textContent, level: e.attrs.level, id: e.attrs.id });
  }), r;
}, be = (n, a = !1) => (r) => {
  const t = r.get(y), s = r.get(M)(n);
  if (!s)
    return;
  if (!a) {
    const { state: m } = t;
    return t.dispatch(m.tr.replace(0, m.doc.content.size, new K(s.content, 0, 0)));
  }
  const o = r.get(f), c = r.get(L), u = r.get(p), i = G.create({
    schema: o,
    doc: s,
    plugins: u,
    ...c
  });
  t.updateState(i);
}, Oe = (n, a) => (r) => {
  const t = r.get(y), { tr: e } = t.state, s = e.doc.nodeAt(n);
  if (!s)
    return;
  const o = a(s.attrs);
  return t.dispatch(e.setNodeMarkup(n, void 0, o));
}, Re = (...n) => {
  const a = n.length;
  let r = a;
  for (; r--; )
    if (typeof n[r] != "function")
      throw new TypeError("Expected a function");
  return (...t) => {
    let e = 0, s = a ? n[e](...t) : t[0];
    for (; ++e < a; )
      s = n[e](s);
    return s;
  };
};
export {
  re as $command,
  se as $commandAsync,
  h as $ctx,
  ae as $inputRule,
  oe as $inputRuleAsync,
  Q as $mark,
  ce as $markAsync,
  we as $markAttr,
  ge as $markSchema,
  W as $node,
  ie as $nodeAsync,
  he as $nodeAttr,
  ye as $nodeSchema,
  ue as $prose,
  me as $proseAsync,
  ke as $remark,
  X as $shortcut,
  pe as $shortcutAsync,
  fe as $useKeymap,
  le as $view,
  de as $viewAsync,
  g as addTimer,
  Se as callCommand,
  Ce as forceUpdate,
  ve as getHTML,
  $e as getMarkdown,
  Te as insert,
  J as nanoid,
  Ae as outline,
  Re as pipe,
  be as replaceAll,
  Oe as setAttr
};
//# sourceMappingURL=index.es.js.map
