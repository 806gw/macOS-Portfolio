var ve = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
};
var s = (e, t, r) => (ve(e, t, "read from private field"), r ? r.call(e) : t.get(e)), d = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
}, c = (e, t, r, i) => (ve(e, t, "write to private field"), i ? i.call(e, r) : t.set(e, r), r);
import { createTimer as v, createSlice as o, Container as Se, Clock as Be, Ctx as Ye } from "@milkdown/ctx";
import { Schema as $e, DOMParser as qe, Node as He } from "@milkdown/prose/model";
import de from "remark-parse";
import he from "remark-stringify";
import { unified as le } from "unified";
import { ctxCallOutOfScope as Pe, docTypeError as Je, callCommandBeforeEditorView as Fe } from "@milkdown/exception";
import { ParserState as Ge, SerializerState as Qe } from "@milkdown/transformer";
import { PluginKey as Re, Plugin as be, EditorState as Ue } from "@milkdown/prose/state";
import { EditorView as Xe } from "@milkdown/prose/view";
import { customInputRules as Ze } from "@milkdown/prose";
import { baseKeymap as xe } from "@milkdown/prose/commands";
import { keymap as et } from "@milkdown/prose/keymap";
const k = (e, t) => (e.meta = {
  package: "@milkdown/core",
  group: "System",
  ...t
}, e), De = {
  strong: (e, t, r, i) => {
    const n = e.marker || r.options.strong || "*", a = r.enter("strong"), h = r.createTracker(i);
    let m = h.move(n + n);
    return m += h.move(
      r.containerPhrasing(e, {
        before: m,
        after: n,
        ...h.current()
      })
    ), m += h.move(n + n), a(), m;
  },
  emphasis: (e, t, r, i) => {
    const n = e.marker || r.options.emphasis || "*", a = r.enter("emphasis"), h = r.createTracker(i);
    let m = h.move(n);
    return m += h.move(
      r.containerPhrasing(e, {
        before: m,
        after: n,
        ...h.current()
      })
    ), m += h.move(n), a(), m;
  }
}, W = v("ConfigReady"), tt = (e) => {
  const t = (r) => (r.record(W), async () => (await e(r), r.done(W), () => {
    r.clearTimer(W);
  }));
  return k(t, {
    displayName: "Config"
  }), t;
}, M = v("InitReady"), G = o([], "initTimer"), ke = o({}, "editor"), ue = o([], "inputRules"), N = o([], "prosePlugins"), pe = o([], "remarkPlugins"), ye = o([], "nodeView"), we = o([], "markView"), P = o(le().use(de).use(he), "remark"), Q = o({
  handlers: De
}, "remarkStringifyOptions"), rt = (e) => {
  const t = (r) => (r.inject(ke, e).inject(N, []).inject(pe, []).inject(ue, []).inject(ye, []).inject(we, []).inject(Q, {
    handlers: De
  }).inject(P, le().use(de).use(he)).inject(G, [W]).record(M), async () => {
    await r.waitTimers(G);
    const i = r.get(Q);
    return r.set(P, le().use(de).use(he, i)), r.done(M), () => {
      r.remove(ke).remove(N).remove(pe).remove(ue).remove(ye).remove(we).remove(Q).remove(P).remove(G).clearTimer(M);
    };
  });
  return k(t, {
    displayName: "Init"
  }), t;
}, R = v("SchemaReady"), U = o([], "schemaTimer"), b = o({}, "schema"), X = o([], "nodes"), Z = o([], "marks"), Te = (e) => {
  var t;
  return {
    ...e,
    parseDOM: (t = e.parseDOM) == null ? void 0 : t.map((r) => ({ priority: e.priority, ...r }))
  };
}, Ee = (e) => (e.inject(b, {}).inject(X, []).inject(Z, []).inject(U, [M]).record(R), async () => {
  await e.waitTimers(U);
  const t = e.get(P), i = e.get(pe).reduce((m, y) => m.use(y.plugin, y.options), t);
  e.set(P, i);
  const n = Object.fromEntries(e.get(X).map(([m, y]) => [m, Te(y)])), a = Object.fromEntries(e.get(Z).map(([m, y]) => [m, Te(y)])), h = new $e({ nodes: n, marks: a });
  return e.set(b, h), e.done(R), () => {
    e.remove(b).remove(X).remove(Z).remove(U).clearTimer(R);
  };
});
k(Ee, {
  displayName: "Schema"
});
const B = v("ParserReady"), Ve = () => {
  throw Pe();
}, Y = o(Ve, "parser"), x = o([], "parserTimer"), Ie = (e) => (e.inject(Y, Ve).inject(x, [R]).record(B), async () => {
  await e.waitTimers(x);
  const t = e.get(P), r = e.get(b);
  return e.set(Y, Ge.create(r, t)), e.done(B), () => {
    e.remove(Y).remove(x).clearTimer(B);
  };
});
k(Ie, {
  displayName: "Parser"
});
const $ = v("SerializerReady"), ee = o([], "serializerTimer"), Me = () => {
  throw Pe();
}, te = o(Me, "serializer"), Ne = (e) => (e.inject(te, Me).inject(ee, [R]).record($), async () => {
  await e.waitTimers(ee);
  const t = e.get(P), r = e.get(b);
  return e.set(te, Qe.create(r, t)), e.done($), () => {
    e.remove(te).remove(ee).clearTimer($);
  };
});
k(Ne, {
  displayName: "Serializer"
});
const re = o("", "defaultValue"), I = o({}, "editorState"), se = o((e) => e, "stateOptions"), ie = o([], "editorStateTimer"), q = v("EditorStateReady"), st = (e, t, r) => {
  if (typeof e == "string")
    return t(e);
  if (e.type === "html")
    return qe.fromSchema(r).parse(e.dom);
  if (e.type === "json")
    return He.fromJSON(r, e.value);
  throw Je(e);
}, it = new Re("MILKDOWN_STATE_TRACKER"), _e = (e) => (e.inject(re, "").inject(I, {}).inject(se, (t) => t).inject(ie, [B, $, J]).record(q), async () => {
  await e.waitTimers(ie);
  const t = e.get(b), r = e.get(Y), i = e.get(ue), n = e.get(se), a = e.get(N), h = e.get(re), m = st(h, r, t), y = [
    ...a,
    new be({
      key: it,
      state: {
        init: () => {
        },
        apply: (Le, F, mt, We) => {
          e.set(I, We);
        }
      }
    }),
    Ze({ rules: i }),
    et(xe)
  ];
  e.set(N, y);
  const L = n({
    schema: t,
    doc: m,
    plugins: y
  }), l = Ue.create(L);
  return e.set(I, l), e.done(q), () => {
    e.remove(re).remove(I).remove(se).remove(ie).clearTimer(q);
  };
});
k(_e, {
  displayName: "EditorState"
});
const ne = v("EditorViewReady"), H = o({}, "editorView"), oe = o([], "editorViewTimer"), ae = o({}, "editorViewOptions"), ce = o(null, "root"), fe = o(null, "rootDOM"), ge = o({}, "rootAttrs"), nt = (e, t) => {
  const r = document.createElement("div");
  r.className = "milkdown", e.appendChild(r), t.set(fe, r);
  const i = t.get(ge);
  return Object.entries(i).forEach(([n, a]) => r.setAttribute(n, a)), r;
}, ot = (e) => {
  e.classList.add("editor"), e.setAttribute("role", "textbox");
}, at = new Re("MILKDOWN_VIEW_CLEAR"), ze = (e) => (e.inject(ce, document.body).inject(H, {}).inject(ae, {}).inject(fe, null).inject(ge, {}).inject(oe, [q]).record(ne), async () => {
  await e.wait(M);
  const t = e.get(ce) || document.body, r = typeof t == "string" ? document.querySelector(t) : t;
  e.update(N, (y) => [
    new be({
      key: at,
      view: (L) => {
        const l = r ? nt(r, e) : void 0;
        return (() => {
          if (l && r) {
            const F = L.dom;
            r.replaceChild(l, F), l.appendChild(F);
          }
        })(), {
          destroy: () => {
            l != null && l.parentNode && (l == null || l.parentNode.replaceChild(L.dom, l)), l == null || l.remove();
          }
        };
      }
    }),
    ...y
  ]), await e.waitTimers(oe);
  const i = e.get(I), n = e.get(ae), a = Object.fromEntries(e.get(ye)), h = Object.fromEntries(e.get(we)), m = new Xe(r, {
    state: i,
    nodeViews: a,
    markViews: h,
    ...n
  });
  return ot(m.dom), e.set(H, m), e.done(ne), () => {
    m == null || m.destroy(), e.remove(ce).remove(H).remove(ae).remove(fe).remove(ge).remove(oe).clearTimer(ne);
  };
});
k(ze, {
  displayName: "EditorView"
});
var T, g;
class Ae {
  constructor() {
    d(this, T, void 0);
    d(this, g, void 0);
    c(this, T, new Se()), c(this, g, null), this.setCtx = (t) => {
      c(this, g, t);
    };
  }
  get ctx() {
    return s(this, g);
  }
  /// Register a command into the manager.
  create(t, r) {
    const i = t.create(s(this, T).sliceMap);
    return i.set(r), i;
  }
  get(t) {
    return s(this, T).get(t).get();
  }
  remove(t) {
    return s(this, T).remove(t);
  }
  call(t, r) {
    if (s(this, g) == null)
      throw Fe();
    const n = this.get(t)(r), a = s(this, g).get(H);
    return n(a.state, a.dispatch, a);
  }
}
T = new WeakMap(), g = new WeakMap();
const Ot = (e = "cmdKey") => o(() => () => !1, e), Oe = o(new Ae(), "commands"), me = o([R], "commandsTimer"), J = v("CommandsReady"), Ke = (e) => {
  const t = new Ae();
  return t.setCtx(e), e.inject(Oe, t).inject(me, [R]).record(J), async () => (await e.waitTimers(me), e.done(J), () => {
    e.remove(Oe).remove(me).clearTimer(J);
  });
};
k(Ke, {
  displayName: "Commands"
});
var ct = /* @__PURE__ */ ((e) => (e.Idle = "Idle", e.OnCreate = "OnCreate", e.Created = "Created", e.OnDestroy = "OnDestroy", e.Destroyed = "Destroyed", e))(ct || {}), O, p, w, D, _, z, u, f, j, A, S, E, K, C, V;
const Ce = class {
  constructor() {
    d(this, O, void 0);
    d(this, p, void 0);
    d(this, w, void 0);
    d(this, D, void 0);
    d(this, _, void 0);
    d(this, z, void 0);
    d(this, u, void 0);
    d(this, f, void 0);
    d(this, j, void 0);
    d(this, A, void 0);
    d(this, S, void 0);
    d(this, E, void 0);
    d(this, K, void 0);
    d(this, C, void 0);
    d(this, V, void 0);
    c(this, O, !1), c(this, p, "Idle"), c(this, w, []), c(this, D, () => {
    }), c(this, _, new Se()), c(this, z, new Be()), c(this, u, /* @__PURE__ */ new Map()), c(this, f, /* @__PURE__ */ new Map()), c(this, j, new Ye(s(this, _), s(this, z))), c(this, A, () => {
      const t = tt(async (i) => {
        await Promise.all(s(this, w).map((n) => n(i)));
      }), r = [
        Ee,
        Ie,
        Ne,
        Ke,
        _e,
        ze,
        rt(this),
        t
      ];
      s(this, S).call(this, r, s(this, f));
    }), c(this, S, (t, r) => {
      t.forEach((i) => {
        const n = s(this, j).produce(s(this, O) ? i.meta : void 0), a = i(n);
        r.set(i, { ctx: n, handler: a, cleanup: void 0 });
      });
    }), c(this, E, (t, r = !1) => Promise.all(
      [t].flat().map((i) => {
        const n = s(this, u).get(i), a = n == null ? void 0 : n.cleanup;
        return r ? s(this, u).delete(i) : s(this, u).set(i, { ctx: void 0, handler: void 0, cleanup: void 0 }), typeof a == "function" ? a() : a;
      })
    )), c(this, K, async () => {
      await Promise.all([...s(this, f).entries()].map(([t, { cleanup: r }]) => typeof r == "function" ? r() : r)), s(this, f).clear();
    }), c(this, C, (t) => {
      c(this, p, t), s(this, D).call(this, t);
    }), c(this, V, (t) => [...t.entries()].map(async ([r, i]) => {
      const { ctx: n, handler: a } = i;
      if (!a)
        return;
      const h = await a();
      t.set(r, { ctx: n, handler: a, cleanup: h });
    })), this.enableInspector = (t = !0) => (c(this, O, t), this), this.onStatusChange = (t) => (c(this, D, t), this), this.config = (t) => (s(this, w).push(t), this), this.removeConfig = (t) => (c(this, w, s(this, w).filter((r) => r !== t)), this), this.use = (t) => {
      const r = [t].flat();
      return r.flat().forEach((i) => {
        s(this, u).set(i, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        });
      }), s(this, p) === "Created" && s(this, S).call(this, r, s(this, u)), this;
    }, this.remove = async (t) => s(this, p) === "OnCreate" ? (console.warn("[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code."), new Promise((r) => {
      setTimeout(() => {
        r(this.remove(t));
      }, 50);
    })) : (await s(this, E).call(this, [t].flat(), !0), this), this.create = async () => s(this, p) === "OnCreate" ? this : (s(this, p) === "Created" && await this.destroy(), s(this, C).call(this, "OnCreate"), s(this, A).call(this), s(this, S).call(this, [...s(this, u).keys()], s(this, u)), await Promise.all(
      [
        s(this, V).call(this, s(this, f)),
        s(this, V).call(this, s(this, u))
      ].flat()
    ), s(this, C).call(this, "Created"), this), this.destroy = async (t = !1) => s(this, p) === "Destroyed" || s(this, p) === "OnDestroy" ? this : s(this, p) === "OnCreate" ? new Promise((r) => {
      setTimeout(() => {
        r(this.destroy(t));
      }, 50);
    }) : (t && c(this, w, []), s(this, C).call(this, "OnDestroy"), await s(this, E).call(this, [...s(this, u).keys()], t), await s(this, K).call(this), s(this, C).call(this, "Destroyed"), this), this.action = (t) => t(s(this, j)), this.inspect = () => s(this, O) ? [...s(this, f).values(), ...s(this, u).values()].map(({ ctx: t }) => {
      var r;
      return (r = t == null ? void 0 : t.inspector) == null ? void 0 : r.read();
    }).filter((t) => !!t) : (console.warn("[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first."), []);
  }
  /// Create a new editor instance.
  static make() {
    return new Ce();
  }
  /// Get the ctx of the editor.
  get ctx() {
    return s(this, j);
  }
  /// Get the status of the editor.
  get status() {
    return s(this, p);
  }
};
let je = Ce;
O = new WeakMap(), p = new WeakMap(), w = new WeakMap(), D = new WeakMap(), _ = new WeakMap(), z = new WeakMap(), u = new WeakMap(), f = new WeakMap(), j = new WeakMap(), A = new WeakMap(), S = new WeakMap(), E = new WeakMap(), K = new WeakMap(), C = new WeakMap(), V = new WeakMap();
export {
  Ae as CommandManager,
  J as CommandsReady,
  W as ConfigReady,
  je as Editor,
  q as EditorStateReady,
  ct as EditorStatus,
  ne as EditorViewReady,
  M as InitReady,
  B as ParserReady,
  R as SchemaReady,
  $ as SerializerReady,
  Ke as commands,
  Oe as commandsCtx,
  me as commandsTimerCtx,
  tt as config,
  Ot as createCmdKey,
  re as defaultValueCtx,
  ke as editorCtx,
  _e as editorState,
  I as editorStateCtx,
  se as editorStateOptionsCtx,
  ie as editorStateTimerCtx,
  ze as editorView,
  H as editorViewCtx,
  ae as editorViewOptionsCtx,
  oe as editorViewTimerCtx,
  st as getDoc,
  rt as init,
  G as initTimerCtx,
  ue as inputRulesCtx,
  we as markViewCtx,
  Z as marksCtx,
  ye as nodeViewCtx,
  X as nodesCtx,
  Ie as parser,
  Y as parserCtx,
  x as parserTimerCtx,
  N as prosePluginsCtx,
  P as remarkCtx,
  pe as remarkPluginsCtx,
  Q as remarkStringifyOptionsCtx,
  ge as rootAttrsCtx,
  ce as rootCtx,
  fe as rootDOMCtx,
  Ee as schema,
  b as schemaCtx,
  U as schemaTimerCtx,
  Ne as serializer,
  te as serializerCtx,
  ee as serializerTimerCtx
};
//# sourceMappingURL=index.es.js.map
